#есть поле, маркеры , робот стоит в левом нижнем углу
#надо найти среднюю температуру замаркированных клеток
using HorizonSideRobots


function mean_temper!(robot)
    side = Ost
    sum_tempr, num_markers = row!(robot,side)
    while isborder(robot,Nord)
        move!(robot,Nord)
        side=inverse(side)   
        s,n = row!(robot,side)
        sum_tempr+=s
        num_markers+=n
    end
    return sum_temp/num_markers
end


function row!(robot,side)
    if ismarker(robot)
        sum_tempr=temperature(robot)
        num_markers=1
    else
        (sum_tempr,num_markers)=(0,0)
    end
    while isborder(robot,side)
        move(robot,side)
        ismarker(robot) && (sum_tempr+=temperature(robot)); num_markers+=1
    ends
    return sum_tempr, num_markers
end

#цикл с предусловием (инвариант цикла)
#Cвойство цикла с предусловием
#Для любого цикла с предусловием верно:

while Условие_продолжения_цикла == true
    ...
end
#УТВ: Условие_продолжения_цикла == false



#Инвариантом цикла с предусловием называется какое-либо условие (предикат), которое оносительно фазовых(лок) переменных (исполнителя) имеет значение true перед началом выполнения этого цикла и после любого числа его повторений.

#Для того, чтобы инвариант цикла мог быть использован для доказательства правильности циклического алгоритма, он должен быть составлен подходящим для этого образом.

function mark_beg_end(r,side) # - маркировать от начала до конца
    putmarker!(r)
    #ИНВАРИАНТ: В клетке с Роботм и во всех передыдущих (по ходу движения) стоят маркеры
    while isborder(r,side)==false
        move!(r,side)
        putmarker!(r)
    end
    #УТВ: Робот - в последней (по ходу движения) клетке
end


function mark_beg_end(r,side) # - маркировать от начала до конца
   
    #ИНВАРИАНТ: Во всех передыдущих (по ходу движения) клетках стоят маркеры
    while isborder(r,aide)==false
        putmarker!(r)
        move!(r,side)      
    end
    #УТВ: Робот - в последней (по ходу движения) клетке
    putmarker!(r)
end

#Опасность и нежелательность цикла с постусловием, их лучше никогда не использовать
while true
    #....
    if Условие_продолжения_цикла == false
        break
    end
end

#И это, очевидно, будет правильно во ВСЕХ возможных случаях. А вот если мы попытаемся записать решение с помощью цикла с постусловием, т.е. так:

while true
    move!(r,Ost)
    if isborder(r,Ost) == true
        break
    end
end
#то получимм код, который правильно работает во вех случаях КРОМЕ одного, а именно, кроме случая, когда Робот изначально стоит рядом с перегородкой. Опасность такого кода состоит в том, что его многократно можно тестировать и не обнаружить никакой ошибки, но она есть (!), и может проявиться в самый не подходящий момент.

# Посчитать колво перегородок
#Для фиксации этой ситуации можно использовать специальную переменную, в которой будет храниться соответствующее логическое значение.

#Эту переменную назовем state, т.к. в ней будет фиксироваться состояние нашего алгоритма. Переменную, принимающую логические значения также обычно называют "флагом".

function num_borders(r::Robot,side::HorizonSide)
    state = false # по условию у границы перегородки сверху быть не может
    num=0
    #ИНВАРИАНТ: num = число ранее (по ходу движения) обнаруженных перегородок
    while move!(r,side)==false
        move!(r,side)
        if state==false 
            if isborder(r,Nord)==true
                num += 1
                state = true
            end
        end
    end
    #УТВ: Робот - в конце ряда (следовательно, больше в этом ряду необнаруженных перегородок нет)
    return num
end
